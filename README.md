项目目标
=

MPT的学习报告

报告内容
=

__前期储备__
_________

__前缀树__

前缀树，又称字典树，用于保存关键数组，通常它的Keys决定了其存储位置，又可以说，它的Keys就是他在树中的存储路径。

![image](http://upyun-assets.ethfans.org/uploads/photo/image/377eb3b9b99849d3adbc9f77feedbd18.jpeg)

相较于Hash表，使用前缀树查询具有相同前缀的数据十分高效，且不会出现Hash冲突的问题。但是它直接查找的效率比较低
，查找效率均为O(n），并且若存在一个节点Keys很长时，会创建许多节点进行储存，造成空间的浪费。

__Merkle Tree__

Merkle Tree是将所有节点自上而下两两组合进行Hash，最终只得到一个根节点Hash值的数据结构。

![image](http://upyun-assets.ethfans.org/uploads/photo/image/b82fb25ae13d4ff199f2386b54632298.png)

如图所示，将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。
如果该层的树节点个数是单数，那么对于最后剩下的树节点，这种情况就直接对它进行哈希运算。若两棵树的根Hash一致，则这两棵树完全相同。

优势：

1.快速重哈希：

默克尔树的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。

2.轻节点扩展：

采用默克尔树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

劣势：存储开销大

__定义__
_________________

Merkle Patricia Tree（又称为Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

MPT有以下作用：

1.存储任意长度键值对数据

2.提供了一种快速计算所维护数据集哈希标识的机制

3.提供了快速状态回滚的机制

4.提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证


__节点__
___________________

1.空节点：表示空串

2.分支节点：用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点

3.叶子节点/扩展节点：存储属于该节点范围的Keys以及内容

针对前缀树路径过长情况，MPT给出了如下解决方案：

![image](http://upyun-assets.ethfans.org/uploads/photo/image/0286b2c9a99c48179c744ba889648112.jpeg)

若后续没有其他节点，那个MPT将其后路径全部压缩，达到减少空间的目的。

这种做法有以下优势：

1.提高节点的查找效率，避免过多的磁盘访问

2.减少存储空间浪费，避免存储无用的节点

__编码__
_______________________

在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求.

三种编码方式分别为：

1.Raw编码（原生的字符）：Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。

2.Hex编码（扩展的16进制编码）

3.Hex-Prefix编码（16进制前缀编码）：区分叶子节点/扩展节点

其中从Raw编码向Hex编码的转换规则是：

1.将Raw编码的每个字符，根据高4位低4位拆成两个字节

2.若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符

3.若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符

HP编码的规则如下：

1.若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节

2.在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1

3.若原本key的长度为奇数，则在key之前再增加一个值为0x0的半字节

4.将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）

转换关系为：

![image](http://upyun-assets.ethfans.org/uploads/photo/image/bac0731f81cb4a2d9ac71abd6f9bcdc9.jpeg)

__安全的MPT__
______________________

以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

1.查询一个节点可能会需要许多次IO读取，效率低下

2.系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降

3.所有的key其实是一种明文的形式进行存储

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是
`(sha3(key), value)

__具体结构__
__________________

![image](https://img-blog.csdnimg.cn/img_convert/0e1cb62d4e3e00b380392dc240f284e8.png)

这里使用不同的header值来表示不同的节点类型，即01表示叶子节点，10表示无值的分支节点，11表示有值的分支节点。

之后将节点进行Hash：

![image](https://img-blog.csdnimg.cn/img_convert/7f46515edcebf2d358aaa632a869bcc7.png)

首先计算出叶子节点的哈希值，它们被上一级的分支节点所引用，用来在数据库中查找对应的节点；然后计算分支节点的哈希值，直至递归抵达根节点。


__MPT的部分操作__
__________________

__GET__

我们以一个例子来说明

![image](http://upyun-assets.ethfans.org/uploads/photo/image/de14289b6b094164a7b6ccaa66ff59f0.jpeg)

上图为寻找cat操作，其具体过程为：

1.将key"cat"转换成hex编码[3,15,3,13,4,10,T]

2.当前节点是根节点，且是扩展节点，其key为3,15，则递归地对其子节点进行查找调用，剩余的搜索路径为[3,13,4,10,T]

3.当前节点是分支节点，以搜索路径的第一个字节内容3选择第4个孩子节点递归进行查找，剩余的搜索路径为[13,4,10,T]

4.当前节点是叶子节点，且key与剩余的搜索路径一致，表示找到了该节点，返回Val为“dog”

__Insert__

插入操作基于查找完成，首先找到与新插入节点拥有最长相同路径前缀的节点，之后基于此节点将剩下的节点进行封装插入。


__存在性证明__
______________________

如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在与默克尔树中，只需要向全节点发送该请求，全节点会返回一个1FXq:18, ec20,
8f74的一个路径（默克尔路径，如图2黄色框所表示的）。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。

![image](http://upyun-assets.ethfans.org/uploads/photo/image/5409681f672c465db8b49ee4ac6f4dd0.jpeg)

代码介绍
=

在此我简单模拟了一下课堂中给出的例子。

首先在MPT_Node.h中定义结构体，里面包括：prefix、shared_nibbles、value、leaf（是否是叶节点）以及子节点，以此作为
树上的单个节点。

之后根据课堂例子

`a711355 45
`a77d337 1
`a7f9365 2
`a77d397 5

创建具体的MPT。后续又写了存在性证明以及不存在性证明。

运行指导
=

可直接运行

运行截图
=

![image](https://github.com/CLiangH/Picture/blob/main/MPT1.png)

参考资料
=

[1]https://blog.csdn.net/tianlongtc/article/details/80418923
[2]https://blog.csdn.net/shangsongwww/article/details/119272573
